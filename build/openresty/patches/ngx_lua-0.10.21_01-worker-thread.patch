diff --git a/bundle/ngx_lua-0.10.21/src/ngx_http_lua_common.h b/bundle/ngx_lua-0.10.21/src/ngx_http_lua_common.h
index ed88f0a..d4edb7a 100644
--- a/bundle/ngx_lua-0.10.21/src/ngx_http_lua_common.h
+++ b/bundle/ngx_lua-0.10.21/src/ngx_http_lua_common.h
@@ -468,6 +468,9 @@ struct ngx_http_lua_co_ctx_s {
     ngx_str_t               *sr_bodies;   /* all captured subrequest bodies */
 
     uint8_t                 *sr_flags;
+    unsigned                 nresults_from_worker_thread;  /* number of results
+                                                        * from worker
+                                                        * thread callback */
 
     unsigned                 nsubreqs;  /* number of subrequests of the
                                          * current request */
diff --git a/bundle/ngx_lua-0.10.21/src/ngx_http_lua_worker_thread.c b/bundle/ngx_lua-0.10.21/src/ngx_http_lua_worker_thread.c
index 5133fa6..ed7b089 100644
--- a/bundle/ngx_lua-0.10.21/src/ngx_http_lua_worker_thread.c
+++ b/bundle/ngx_lua-0.10.21/src/ngx_http_lua_worker_thread.c
@@ -16,7 +16,12 @@
 #include "ngx_http_lua_util.h"
 #include "ngx_http_lua_string.h"
 #include "ngx_http_lua_config.h"
+#include "ngx_http_lua_shdict.h"
 
+#ifndef STRINGIFY
+#define TOSTRING(x)  #x
+#define STRINGIFY(x) TOSTRING(x)
+#endif
 
 #if (NGX_THREADS)
 
@@ -24,6 +29,7 @@
 #include <ngx_thread.h>
 #include <ngx_thread_pool.h>
 
+#define LUA_COPY_MAX_DEPTH 100
 
 typedef struct ngx_http_lua_task_ctx_s {
     lua_State                        *vm;
@@ -139,14 +145,16 @@ ngx_http_lua_get_task_ctx(lua_State *L, ngx_http_request_t *r)
         lua_setfield(vm, -2, "path");
         lua_pushlstring(vm, cpath, cpath_len);
         lua_setfield(vm, -2, "cpath");
+        lua_pop(vm, 1);
 
         /* pop path, cpath and "package" table from L */
         lua_pop(L, 3);
 
         /* inject API from C */
-        lua_newtable(L);    /* ngx.* */
+        lua_newtable(vm);    /* ngx.* */
         ngx_http_lua_inject_string_api(vm);
         ngx_http_lua_inject_config_api(vm);
+        ngx_http_lua_inject_shdict_api(lmcf, vm);
         lua_setglobal(vm, "ngx");
 
         /* inject API via ffi */
@@ -174,6 +182,14 @@ ngx_http_lua_get_task_ctx(lua_State *L, ngx_http_request_t *r)
             return NULL;
         }
 
+        lua_getglobal(vm, "require");
+        lua_pushstring(vm, "resty.core.shdict");
+        if (lua_pcall(vm, 1, 0, 0) != 0) {
+            lua_close(vm);
+            ngx_free(ctx);
+            return NULL;
+        }
+
     } else {
         ctx = ctxpool->next;
         ctxpool->next = ctx->next;
@@ -197,7 +213,7 @@ ngx_http_lua_free_task_ctx(ngx_http_lua_task_ctx_t *ctx)
 
 static int
 ngx_http_lua_xcopy(lua_State *from, lua_State *to, int idx,
-    const int allow_nil)
+    const int allow_nil, const int depth, const char **err)
 {
     size_t           len = 0;
     const char      *str;
@@ -224,6 +240,13 @@ ngx_http_lua_xcopy(lua_State *from, lua_State *to, int idx,
         return LUA_TSTRING;
 
     case LUA_TTABLE:
+        if (depth >= LUA_COPY_MAX_DEPTH) {
+            *err = "suspicious circular references, "
+                   "table depth exceed max depth: "
+                   STRINGIFY(LUA_COPY_MAX_DEPTH);
+            return LUA_TNONE;
+        }
+
         top_from = lua_gettop(from);
         top_to = lua_gettop(to);
 
@@ -237,8 +260,9 @@ ngx_http_lua_xcopy(lua_State *from, lua_State *to, int idx,
         lua_pushnil(from);
 
         while (lua_next(from, idx) != 0) {
-            if (ngx_http_lua_xcopy(from, to, -2, 0) != LUA_TNONE
-                && ngx_http_lua_xcopy(from, to, -1, 0) != LUA_TNONE)
+            if (ngx_http_lua_xcopy(from, to, -2, 0, depth + 1, err) != LUA_TNONE
+                && ngx_http_lua_xcopy(from, to, -1, 0,
+                                      depth + 1, err) != LUA_TNONE)
             {
                 lua_rawset(to, -3);
 
@@ -258,16 +282,24 @@ ngx_http_lua_xcopy(lua_State *from, lua_State *to, int idx,
             lua_pushnil(to);
             return LUA_TNIL;
         }
-        /* fall through */
-
-    /*
-     * ignore unsupported values:
-     * LUA_TNONE
-     * LUA_TFUNCTION
-     * LUA_TUSERDATA
-     * LUA_TTHREAD
-     */
+
+        *err = "unsupported Lua type: LUA_TNIL";
+        return LUA_TNONE;
+
+    case LUA_TFUNCTION:
+        *err = "unsupported Lua type: LUA_TFUNCTION";
+        return LUA_TNONE;
+
+    case LUA_TUSERDATA:
+        *err = "unsupported Lua type: LUA_TUSERDATA";
+        return LUA_TNONE;
+
+    case LUA_TTHREAD:
+        *err = "unsupported Lua type: LUA_TTHREAD";
+        return LUA_TNONE;
+
     default:
+        *err = "unsupported Lua type";
         return LUA_TNONE;
     }
 }
@@ -287,6 +319,50 @@ ngx_http_lua_worker_thread_handler(void *data, ngx_log_t *log)
 }
 
 
+static ngx_int_t
+ngx_http_lua_worker_thread_resume(ngx_http_request_t *r)
+{
+    lua_State                   *vm;
+    ngx_connection_t            *c;
+    ngx_int_t                    rc;
+    ngx_uint_t                   nreqs;
+    ngx_http_lua_ctx_t          *ctx;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_lua_module);
+    if (ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ctx->resume_handler = ngx_http_lua_wev_handler;
+
+    c = r->connection;
+    vm = ngx_http_lua_get_lua_vm(r, ctx);
+    nreqs = c->requests;
+
+    rc = ngx_http_lua_run_thread(vm, r, ctx,
+                                 ctx->cur_co_ctx->nresults_from_worker_thread);
+
+    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                   "lua run thread returned %d", rc);
+
+    if (rc == NGX_AGAIN) {
+        return ngx_http_lua_run_posted_threads(c, vm, r, ctx, nreqs);
+    }
+
+    if (rc == NGX_DONE) {
+        ngx_http_lua_finalize_request(r, NGX_DONE);
+        return ngx_http_lua_run_posted_threads(c, vm, r, ctx, nreqs);
+    }
+
+    if (ctx->entered_content_phase) {
+        ngx_http_lua_finalize_request(r, rc);
+        return NGX_DONE;
+    }
+
+    return rc;
+}
+
+
 /* executed in nginx event loop */
 static void
 ngx_http_lua_worker_thread_event_handler(ngx_event_t *ev)
@@ -299,10 +375,10 @@ ngx_http_lua_worker_thread_event_handler(ngx_event_t *ev)
     size_t                            len;
     const char                       *str;
     int                               i;
-    int                               rc;
     ngx_http_lua_ctx_t               *ctx;
     lua_State                        *vm;
     int                               saved_top;
+    const char                       *err;
 
     worker_thread_ctx = ev->data;
 
@@ -338,10 +414,12 @@ ngx_http_lua_worker_thread_event_handler(ngx_event_t *ev)
         lua_pushboolean(L, 1);
         nresults = lua_gettop(vm) + 1;
         for (i = 1; i < nresults; i++) {
-            if (ngx_http_lua_xcopy(vm, L, i, 1) == LUA_TNONE) {
+            err = NULL;
+            if (ngx_http_lua_xcopy(vm, L, i, 1, 1, &err) == LUA_TNONE) {
                 lua_settop(L, saved_top);
                 lua_pushboolean(L, 0);
-                lua_pushstring(L, "unsupported return value");
+                lua_pushfstring(L, "%s in the return value",
+                                err != NULL ? err : "unsupoorted Lua type");
                 nresults = 2;
                 break;
             }
@@ -349,6 +427,7 @@ ngx_http_lua_worker_thread_event_handler(ngx_event_t *ev)
     }
 
     ctx->cur_co_ctx = worker_thread_ctx->wait_co_ctx;
+    ctx->cur_co_ctx->nresults_from_worker_thread = nresults;
     ctx->cur_co_ctx->cleanup = NULL;
 
     ngx_http_lua_free_task_ctx(worker_thread_ctx->ctx);
@@ -356,30 +435,15 @@ ngx_http_lua_worker_thread_event_handler(ngx_event_t *ev)
 
     /* resume the caller coroutine */
 
-    vm = ngx_http_lua_get_lua_vm(r, ctx);
-
-    rc = ngx_http_lua_run_thread(vm, r, ctx, nresults);
-
-    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
-                   "lua run thread returned %d", rc);
-
-    if (rc == NGX_AGAIN) {
-        ngx_http_lua_run_posted_threads(c, vm, r, ctx, c->requests);
-        return;
-    }
+    if (ctx->entered_content_phase) {
+        (void) ngx_http_lua_worker_thread_resume(r);
 
-    if (rc == NGX_DONE) {
-        ngx_http_lua_finalize_request(r, NGX_DONE);
-        ngx_http_lua_run_posted_threads(c, vm, r, ctx, c->requests);
-        return;
+    } else {
+        ctx->resume_handler = ngx_http_lua_worker_thread_resume;
+        ngx_http_core_run_phases(r);
     }
 
-    /* rc == NGX_ERROR || rc >= NGX_OK */
-
-    if (ctx->entered_content_phase) {
-        ngx_http_lua_finalize_request(r, rc);
-        return;
-    }
+    ngx_http_run_posted_requests(c);
 
     return;
 
@@ -517,9 +581,11 @@ ngx_http_lua_run_worker_thread(lua_State *L)
 
     /* copying passed arguments */
     for (i = 4; i <= n_args; i++) {
-        if (ngx_http_lua_xcopy(L, vm, i, 1) == LUA_TNONE) {
+        err = NULL;
+        if (ngx_http_lua_xcopy(L, vm, i, 1, 1, &err) == LUA_TNONE) {
             lua_pushboolean(L, 0);
-            lua_pushstring(L, "unsupported argument type");
+            lua_pushfstring(L, "%s in the argument",
+                            err != NULL ? err : "unsupoorted Lua type");
             ngx_http_lua_free_task_ctx(tctx);
             return 2;
         }
